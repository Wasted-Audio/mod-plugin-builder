diff --git a/src/Airwindows/XRegion.cpp b/src/Airwindows/XRegion.cpp
index a98bde9..51f2036 100644
--- a/src/Airwindows/XRegion.cpp
+++ b/src/Airwindows/XRegion.cpp
@@ -30,7 +30,7 @@
 #include "XRegion.hpp"
 #include <cstring>
 
-XRegion::XRegion (const double rate) :
+XRegion::XRegion (const float rate) :
     rate (rate),
     params {0.5, 0.5, 0.5, 0.0, 1.0, 0.0}
 {
@@ -43,83 +43,83 @@ XRegion::~XRegion() {}
 
 void XRegion::process (float* input1, float* input2, float* output1, float* output2, int32_t sampleFrames)
 {
-    double gain = pow (params[0] + 0.5, 4);
-	
-	double high = params[1];
-	double low = params[2];
-	double mid = (high + low) * 0.5;
-	double spread = 1.001 - fabs (high - low);
-    double nuke = params[3];
-	
+    float gain = pow (params[0] + 0.5, 4);
+
+	float high = params[1];
+	float low = params[2];
+	float mid = (high + low) * 0.5;
+	float spread = 1.001 - fabs (high - low);
+    float nuke = params[3];
+
 	biquad[0] = high * high * high *20000.0 / rate;
 	if (biquad[0] < 0.00009) biquad[0] = 0.00009;
-	double compensation = sqrt(biquad[0])*6.4*spread;
-	double clipFactor = 0.75+(biquad[0]*nuke*37.0);
-	
-    const double hm = 0.5 * (high + mid);
+	float compensation = sqrt(biquad[0])*6.4*spread;
+	float clipFactor = 0.75+(biquad[0]*nuke*37.0);
+
+    const float hm = 0.5 * (high + mid);
 	biquadA[0] = hm * hm * hm *20000.0 / rate;
 	if (biquadA[0] < 0.00009) biquadA[0] = 0.00009;
-	double compensationA = sqrt(biquadA[0])*6.4*spread;
-	double clipFactorA = 0.75+(biquadA[0]*nuke*37.0);
-	
+	float compensationA = sqrt(biquadA[0])*6.4*spread;
+	float clipFactorA = 0.75+(biquadA[0]*nuke*37.0);
+
 	biquadB[0] = mid * mid * mid *20000.0 / rate;
 	if (biquadB[0] < 0.00009) biquadB[0] = 0.00009;
-	double compensationB = sqrt(biquadB[0])*6.4*spread;
-	double clipFactorB = 0.75+(biquadB[0]*nuke*37.0);
-	
-    const double ml = 0.5 * (mid + low);
+	float compensationB = sqrt(biquadB[0])*6.4*spread;
+	float clipFactorB = 0.75+(biquadB[0]*nuke*37.0);
+
+    const float ml = 0.5 * (mid + low);
 	biquadC[0] = ml * ml * ml * 20000.0 / rate;
 	if (biquadC[0] < 0.00009) biquadC[0] = 0.00009;
-	double compensationC = sqrt(biquadC[0])*6.4*spread;
-	double clipFactorC = 0.75+(biquadC[0]*nuke*37.0);
-	
+	float compensationC = sqrt(biquadC[0])*6.4*spread;
+	float clipFactorC = 0.75+(biquadC[0]*nuke*37.0);
+
 	biquadD[0] = low * low * low * 20000.0 / rate;
 	if (biquadD[0] < 0.00009) biquadD[0] = 0.00009;
-	double compensationD = sqrt(biquadD[0])*6.4*spread;
-	double clipFactorD = 0.75+(biquadD[0]*nuke*37.0);
-	
-	double K = tan(M_PI * biquad[0]);
-	double norm = 1.0 / (1.0 + K / 0.7071 + K * K);
+	float compensationD = sqrt(biquadD[0])*6.4*spread;
+	float clipFactorD = 0.75+(biquadD[0]*nuke*37.0);
+
+	float K = tan(M_PI * biquad[0]);
+	float norm = 1.0 / (1.0 + K / 0.7071 + K * K);
 	biquad[2] = K / 0.7071 * norm;
 	biquad[4] = -biquad[2];
 	biquad[5] = 2.0 * (K * K - 1.0) * norm;
 	biquad[6] = (1.0 - K / 0.7071 + K * K) * norm;
-	
+
 	K = tan(M_PI * biquadA[0]);
 	norm = 1.0 / (1.0 + K / 0.7071 + K * K);
 	biquadA[2] = K / 0.7071 * norm;
 	biquadA[4] = -biquadA[2];
 	biquadA[5] = 2.0 * (K * K - 1.0) * norm;
 	biquadA[6] = (1.0 - K / 0.7071 + K * K) * norm;
-	
+
 	K = tan(M_PI * biquadB[0]);
 	norm = 1.0 / (1.0 + K / 0.7071 + K * K);
 	biquadB[2] = K / 0.7071 * norm;
 	biquadB[4] = -biquadB[2];
 	biquadB[5] = 2.0 * (K * K - 1.0) * norm;
 	biquadB[6] = (1.0 - K / 0.7071 + K * K) * norm;
-	
+
 	K = tan(M_PI * biquadC[0]);
 	norm = 1.0 / (1.0 + K / 0.7071 + K * K);
 	biquadC[2] = K / 0.7071 * norm;
 	biquadC[4] = -biquadC[2];
 	biquadC[5] = 2.0 * (K * K - 1.0) * norm;
 	biquadC[6] = (1.0 - K / 0.7071 + K * K) * norm;
-	
+
 	K = tan(M_PI * biquadD[0]);
 	norm = 1.0 / (1.0 + K / 0.7071 + K * K);
 	biquadD[2] = K / 0.7071 * norm;
 	biquadD[4] = -biquadD[2];
 	biquadD[5] = 2.0 * (K * K - 1.0) * norm;
-	biquadD[6] = (1.0 - K / 0.7071 + K * K) * norm;	
-	
-	double aWet = 1.0;
-	double bWet = 1.0;
-	double cWet = 1.0;
-	double dWet = params[3] * 4.0;
-	double wet = params[4];
-    double pan = params[5];
-	
+	biquadD[6] = (1.0 - K / 0.7071 + K * K) * norm;
+
+	float aWet = 1.0;
+	float bWet = 1.0;
+	float cWet = 1.0;
+	float dWet = params[3] * 4.0;
+	float wet = params[4];
+    float pan = params[5];
+
 	//four-stage wet/dry control using progressive stages that bypass when not engaged
 	if (dWet < 1.0) {aWet = dWet; bWet = 0.0; cWet = 0.0; dWet = 0.0;}
 	else if (dWet < 2.0) {bWet = dWet - 1.0; cWet = 0.0; dWet = 0.0;}
@@ -129,25 +129,23 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 	//output as the control is turned up. Each one independently goes from 0-1 and stays at 1
 	//beyond that point: this is a way to progressively add a 'black box' sound processing
 	//which lets you fall through to simpler processing at lower settings.
-	long double outSample = 0.0;
-	
+	float outSample = 0.0;
+
     while (--sampleFrames >= 0)
     {
-		long double inputSampleL = *input1;
-		long double inputSampleR = *input2;
-		if (fabs(inputSampleL)<1.18e-37) inputSampleL = fpdL * 1.18e-37;
-		if (fabs(inputSampleR)<1.18e-37) inputSampleR = fpdR * 1.18e-37;
-		long double drySampleL = inputSampleL;
-		long double drySampleR = inputSampleR;
-		
+		float inputSampleL = *input1;
+		float inputSampleR = *input2;
+		float drySampleL = inputSampleL;
+		float drySampleR = inputSampleR;
+
 		if (gain != 1.0) {
 			inputSampleL *= gain;
 			inputSampleR *= gain;
 		}
-		
-		long double nukeLevelL = inputSampleL;
-		long double nukeLevelR = inputSampleR;
-		
+
+		float nukeLevelL = inputSampleL;
+		float nukeLevelR = inputSampleR;
+
 		inputSampleL *= clipFactor;
 		if (inputSampleL > 1.57079633) inputSampleL = 1.57079633;
 		if (inputSampleL < -1.57079633) inputSampleL = -1.57079633;
@@ -156,7 +154,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 		biquad[8] = biquad[7]; biquad[7] = inputSampleL; biquad[10] = biquad[9];
 		biquad[9] = outSample; //DF1 left
 		inputSampleL = outSample / compensation; nukeLevelL = inputSampleL;
-		
+
 		inputSampleR *= clipFactor;
 		if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 		if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
@@ -165,7 +163,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 		biquad[12] = biquad[11]; biquad[11] = inputSampleR; biquad[14] = biquad[13];
 		biquad[13] = outSample; //DF1 right
 		inputSampleR = outSample / compensation; nukeLevelR = inputSampleR;
-		
+
 		if (aWet > 0.0) {
 			inputSampleL *= clipFactorA;
 			if (inputSampleL > 1.57079633) inputSampleL = 1.57079633;
@@ -176,7 +174,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 			biquadA[9] = outSample; //DF1 left
 			inputSampleL = outSample / compensationA; inputSampleL = (inputSampleL * aWet) + (nukeLevelL * (1.0-aWet));
 			nukeLevelL = inputSampleL;
-			
+
 			inputSampleR *= clipFactorA;
 			if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 			if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
@@ -197,7 +195,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 			biquadB[9] = outSample; //DF1 left
 			inputSampleL = outSample / compensationB; inputSampleL = (inputSampleL * bWet) + (nukeLevelL * (1.0-bWet));
 			nukeLevelL = inputSampleL;
-			
+
 			inputSampleR *= clipFactorB;
 			if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 			if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
@@ -218,7 +216,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 			biquadC[9] = outSample; //DF1 left
 			inputSampleL = outSample / compensationC; inputSampleL = (inputSampleL * cWet) + (nukeLevelL * (1.0-cWet));
 			nukeLevelL = inputSampleL;
-			
+
 			inputSampleR *= clipFactorC;
 			if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 			if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
@@ -239,7 +237,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 			biquadD[9] = outSample; //DF1 left
 			inputSampleL = outSample / compensationD; inputSampleL = (inputSampleL * dWet) + (nukeLevelL * (1.0-dWet));
 			nukeLevelL = inputSampleL;
-			
+
 			inputSampleR *= clipFactorD;
 			if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 			if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
@@ -250,28 +248,19 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
 			inputSampleR = outSample / compensationD; inputSampleR = (inputSampleR * dWet) + (nukeLevelR * (1.0-dWet));
 			nukeLevelR = inputSampleR;
 		}
-		
+
 		if (inputSampleL > 1.57079633) inputSampleL = 1.57079633;
 		if (inputSampleL < -1.57079633) inputSampleL = -1.57079633;
 		inputSampleL = sin(inputSampleL);
 		if (inputSampleR > 1.57079633) inputSampleR = 1.57079633;
 		if (inputSampleR < -1.57079633) inputSampleR = -1.57079633;
 		inputSampleR = sin(inputSampleR);
-		
+
 		if (wet < 1.0) {
 			inputSampleL = (drySampleL * (1.0-wet))+(inputSampleL * wet);
 			inputSampleR = (drySampleR * (1.0-wet))+(inputSampleR * wet);
 		}
-		
-		//begin 32 bit stereo floating point dither
-		int expon; frexpf((float)inputSampleL, &expon);
-		fpdL ^= fpdL << 13; fpdL ^= fpdL >> 17; fpdL ^= fpdL << 5;
-		inputSampleL += ((double(fpdL)-uint32_t(0x7fffffff)) * 5.5e-36l * (1 << (expon+62)));
-		frexpf((float)inputSampleR, &expon);
-		fpdR ^= fpdR << 13; fpdR ^= fpdR >> 17; fpdR ^= fpdR << 5;
-		inputSampleR += ((double(fpdR)-uint32_t(0x7fffffff)) * 5.5e-36l * (1 << (expon+62)));
-		//end 32 bit stereo floating point dither
-		
+
 		*output1 = inputSampleL * (1.0f - (pan > 0.0f) * pan);
 		*output2 = inputSampleR * (1.0f + (pan < 0.0f) * pan);
 
@@ -282,7 +271,7 @@ void XRegion::process (float* input1, float* input2, float* output1, float* outp
     }
 }
 
-void XRegion::setParameters (const float* values) 
+void XRegion::setParameters (const float* values)
 {
     memcpy (params, values, 6 * sizeof (float));
 }
diff --git a/src/Airwindows/XRegion.hpp b/src/Airwindows/XRegion.hpp
index 2961e9d..00439e4 100644
--- a/src/Airwindows/XRegion.hpp
+++ b/src/Airwindows/XRegion.hpp
@@ -1,6 +1,6 @@
 /* ========================================
  *  XRegion - XRegion.h
- *  Created 8/12/11 by SPIAdmin 
+ *  Created 8/12/11 by SPIAdmin
  *  Copyright (c) 2011 __MyCompanyName__, All rights reserved
  * ======================================== */
 
@@ -38,7 +38,7 @@
 class XRegion
 {
 public:
-    XRegion (const double rate);
+    XRegion (const float rate);
     XRegion (const XRegion& that) = delete;
     ~XRegion();
     XRegion& operator= (const XRegion& that) = delete;
@@ -48,14 +48,14 @@ public:
     void setParameters (const float* values);
 
 private:
-    double rate;
-    long double biquad[15];
-	long double biquadA[15];
-	long double biquadB[15];
-	long double biquadC[15];
-	long double biquadD[15];
-	uint32_t fpdL;
-	uint32_t fpdR;
+    float rate;
+    float biquad[15];
+    float biquadA[15];
+    float biquadB[15];
+    float biquadC[15];
+    float biquadD[15];
+    uint32_t fpdL;
+    uint32_t fpdR;
     float params[6];
 };
 
